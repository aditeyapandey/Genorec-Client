{"ast":null,"code":"// Attributes that can be combined\nvar attrCombination = {\n  \"dotplot\": [\"barsaturation\", \"barhue\"],\n  \"barsize\": [\"barsaturation\", \"barhue\"],\n  \"barsaturation\": [\"dotplot\", \"barsize\"],\n  \"barhue\": [\"dotplot\", \"barsize\"],\n  \"areasize\": [\"areasaturation\", \"areahue\"],\n  \"areasaturation\": [\"areasize\"],\n  \"areahue\": [\"areasize\"]\n}; //Superimposable encodings\n\nvar superimposition = {\n  \"dotplot\": [\"dotplot\", \"linechart\", \"barsize\"],\n  \"linechart\": [\"linechart\", \"dotplot\", \"barsize\"],\n  \"barsize\": [\"dotplot\", \"linechart\"]\n}; //Description:This function is going to take input specifications and try to output a list of visualizable \n//attributes per feature\n//Input: Feature object\n//Output: Returns the tracks \n\nfunction getPossibilities(feature) {\n  var allEncoding = []; //First store all the possible encodings in the dataspec.\n  //Loop through all the options and store the encodings in the allEncoding var\n\n  for (var i = 0; i < feature.length; i++) {\n    var recommendation = feature[i]['recommendation'];\n    var encodingRecommendations = [];\n\n    for (var j = 0; j < recommendation.length; j++) {\n      var encoding = {\n        'attributeId': feature[i]['attributeId'],\n        'encoding': recommendation[j]\n      };\n      encodingRecommendations.push(encoding);\n    }\n\n    allEncoding.push(encodingRecommendations);\n  }\n\n  var encodingOptions = cartesian(allEncoding); //Find the attributes that merge\n\n  var finalEncodingCombination = [];\n\n  for (var x = 0; x < encodingOptions.length; x++) {\n    var set = encodingOptions[x];\n    finalEncodingCombination.push(combineLogic(set));\n  } //Superimpose Attributes\n\n\n  var finalSuperimposed = [];\n\n  for (var x = 0; x < finalEncodingCombination.length; x++) {\n    var set = finalEncodingCombination[x];\n    finalSuperimposed.push(superimposeLogic(set));\n  }\n\n  return finalSuperimposed;\n} //Description: Checks if two variables can be combined, based on decision rules.\n\n\nfunction canCombine(a, b) {\n  var listOfCombinedAttr = attrCombination[a];\n\n  if (listOfCombinedAttr == undefined) {\n    return false;\n  }\n\n  return listOfCombinedAttr.indexOf(b) != -1 ? true : false;\n} //Description: Check if two items groups/individual atttributes can be superimposed\n//Input Both a and b are array and we will do a cartesian combination and check \n\n\nfunction canSuperimposed(a, b) {\n  var canSuperimposed = [];\n  var allcombinations = cartesian([a, b]);\n\n  for (var i = 0; i < allcombinations.length; i++) {\n    var a = allcombinations[i][0];\n    var b = allcombinations[i][1];\n\n    if (superimposition[a] == undefined || superimposition[a] == undefined) {\n      canSuperimposed.push(false);\n      continue;\n    }\n\n    superimposition[a].indexOf(b) != -1 ? canSuperimposed.push(true) : canSuperimposed.push(false); // Incorrect\n  } // console.log(\"boolean array\", canSuperimposed) \n\n\n  return canSuperimposed.every(v => v === true);\n} //Description: Algorithm to superimpose\n\n\nfunction superimposeLogic(arr) {\n  var finalSuperImposed = [];\n  var visited = arr.map(val => {\n    return 0;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    if (visited[i] == 0) {\n      var superImpositionNotFound = true;\n      var a = arr[i];\n      var addSuperImposed = [];\n      var aEncoding = arr[i].map(val => {\n        return val['encoding'];\n      });\n\n      for (var j = 0; j < arr.length; j++) {\n        if (visited[j] == 0) {\n          if (i == j) {\n            continue;\n          } // Skip the same \n\n\n          var b = arr[j];\n          var bEncoding = arr[j].map(val => {\n            return val['encoding'];\n          });\n\n          if (canSuperimposed(aEncoding, bEncoding)) {\n            visited[j] = 1;\n            b.map(arr => {\n              arr[\"superimposed\"] = true;\n            });\n            addSuperImposed.push(...b);\n            superImpositionNotFound = false;\n            continue;\n          }\n        }\n      }\n\n      a.map(arr => {\n        arr[\"superimposed\"] = !superImpositionNotFound;\n      });\n      addSuperImposed.push(...a);\n      finalSuperImposed.push(addSuperImposed);\n    }\n  }\n\n  return finalSuperImposed;\n} //Description: This method returns a combined list of attributes\n//Input: Array of object containing the attribtue id and encoding recoomendation\n//Output: Array of combined and non-combined attributes. E.g [[a1_dotplot,a2_barchart],[a3_annotation]]\n\n\nfunction combineLogic(arr) {\n  var finalEncodingCombination = [];\n  var visited = arr.map(val => {\n    return 0;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    if (visited[i] == 0) {\n      var combinationNotFound = true; // This variable will keep track incase the combination was found \n\n      var a = Object.assign({}, arr[i]);\n\n      for (var j = 0; j < arr.length; j++) {\n        if (visited[j] == 0) {\n          var b = Object.assign({}, arr[j]);\n\n          if (a['attributeId'] == b['attributeId']) {\n            continue;\n          } else {\n            var combine = canCombine(a['encoding'], b['encoding']);\n\n            if (combine) {\n              visited[i] = 1;\n              visited[j] = 1; // finalEncodingCombination.push(`${a['attributeId']}_${a['encoding']}_${b['encoding']}`)\n\n              a['combined'] = true;\n              b['combined'] = true;\n              finalEncodingCombination.push([a, b]);\n              combinationNotFound = false;\n              break;\n            }\n          }\n        }\n      }\n\n      if (combinationNotFound) {\n        a['combined'] = false;\n        finalEncodingCombination.push([a]);\n      }\n    }\n  }\n\n  return finalEncodingCombination;\n} //Description: Test function to evaluate combinations of attributes\n//Input: Array of arrays that have to be combined\n//Output: All possible combinations of the arrays\n\n\nfunction cartesian(args) {\n  var r = [],\n      max = args.length - 1;\n\n  function helper(arr, i) {\n    for (var j = 0, l = args[i].length; j < l; j++) {\n      var a = arr.slice(0); // clone arr\n\n      a.push(args[i][j]);\n      if (i == max) r.push(a);else helper(a, i + 1);\n    }\n  }\n\n  helper([], 0);\n  return r;\n} //Description: This function will list all the tasks a user may have requested for in the dataspec at a feature level.\n//Input: An entire Feature input\n//Output: List of tasks users wants to perform\n\n\nfunction getTasks(feature) {\n  let tasks = new Set();\n\n  for (var i = 0; i < feature.length; i++) {\n    var currentFeature = feature[i];\n\n    if (currentFeature['inputVectorObject']['inputVectorObject']['compare'] == 1) {\n      tasks.add(\"compare\");\n    }\n\n    if (currentFeature['inputVectorObject']['inputVectorObject']['identify'] == 1) {\n      tasks.add(\"identify\");\n    }\n\n    if (currentFeature['inputVectorObject']['inputVectorObject']['summarize'] == 1) {\n      tasks.add(\"summarize\");\n    }\n  }\n\n  return tasks;\n}\n\nfunction getTracks(encodingSpecification) {\n  var featureKeys = Object.keys(encodingSpecification);\n  var trackList = [];\n\n  for (i = 0; i < featureKeys.length; i++) {\n    var tasks = getTasks(encodingSpecification[featureKeys[i]]);\n    var trackPossibilities = getPossibilities(encodingSpecification[featureKeys[i]]);\n    var featureId = `feature_${i}`;\n    var returnTrackSpec = {\n      [featureId]: {\n        trackPossibilities,\n        tasks\n      }\n    }; // console.log(`Stage 2 Output`, returnTrackSpec)\n\n    trackList.push(returnTrackSpec);\n  }\n\n  return trackList;\n}\n\nmodule.exports = getTracks;","map":{"version":3,"sources":["/Users/aditeyapandey/Documents/Genorec_Client/node_modules/genorec-engine/src/s2_ca.js"],"names":["attrCombination","superimposition","getPossibilities","feature","allEncoding","i","length","recommendation","encodingRecommendations","j","encoding","push","encodingOptions","cartesian","finalEncodingCombination","x","set","combineLogic","finalSuperimposed","superimposeLogic","canCombine","a","b","listOfCombinedAttr","undefined","indexOf","canSuperimposed","allcombinations","every","v","arr","finalSuperImposed","visited","map","val","superImpositionNotFound","addSuperImposed","aEncoding","bEncoding","combinationNotFound","Object","assign","combine","args","r","max","helper","l","slice","getTasks","tasks","Set","currentFeature","add","getTracks","encodingSpecification","featureKeys","keys","trackList","trackPossibilities","featureId","returnTrackSpec","module","exports"],"mappings":"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","sourcesContent":["\n// Attributes that can be combined\nvar attrCombination = {\n    \"dotplot\":[\"barsaturation\",\"barhue\"],\n    \"barsize\":[\"barsaturation\",\"barhue\"],\n    \"barsaturation\":[\"dotplot\",\"barsize\"],\n    \"barhue\":[\"dotplot\",\"barsize\"],\n    \"areasize\":[\"areasaturation\",\"areahue\"],\n    \"areasaturation\":[\"areasize\"],\n    \"areahue\":[\"areasize\"]\n}\n\n//Superimposable encodings\nvar superimposition = {\n    \"dotplot\": [\"dotplot\",\"linechart\",\"barsize\"],\n    \"linechart\": [\"linechart\",\"dotplot\",\"barsize\"],\n    \"barsize\":[\"dotplot\",\"linechart\"]\n}\n\n//Description:This function is going to take input specifications and try to output a list of visualizable \n//attributes per feature\n//Input: Feature object\n//Output: Returns the tracks \nfunction getPossibilities(feature)\n{\n    var allEncoding = []//First store all the possible encodings in the dataspec.\n\n    //Loop through all the options and store the encodings in the allEncoding var\n    for (var i=0; i<feature.length;i++)\n    {    \n        var recommendation = feature[i]['recommendation']\n        var encodingRecommendations = []\n        for (var j=0; j<recommendation.length; j++){\n            var encoding = {'attributeId':feature[i]['attributeId'], 'encoding':recommendation[j]}\n            encodingRecommendations.push(encoding)\n        }\n        allEncoding.push(encodingRecommendations)\n    } \n\n    var encodingOptions = cartesian(allEncoding)\n\n    //Find the attributes that merge\n    var finalEncodingCombination = [];\n    for (var x = 0; x< encodingOptions.length; x++){\n      var set = encodingOptions[x]  \n      finalEncodingCombination.push(combineLogic(set))\n    }\n   \n    //Superimpose Attributes\n    var finalSuperimposed = []\n    for (var x=0;x<finalEncodingCombination.length;x++)\n    {\n        var set  = finalEncodingCombination[x]\n        finalSuperimposed.push(superimposeLogic(set))\n    }\n\n    return finalSuperimposed\n}\n\n//Description: Checks if two variables can be combined, based on decision rules.\nfunction canCombine(a,b){\n    var listOfCombinedAttr = attrCombination[a]\n    if(listOfCombinedAttr == undefined) {return false}\n    return listOfCombinedAttr.indexOf(b) != -1 ? true : false\n}\n\n//Description: Check if two items groups/individual atttributes can be superimposed\n//Input Both a and b are array and we will do a cartesian combination and check \nfunction canSuperimposed(a,b){\n    var canSuperimposed = []\n    var allcombinations = cartesian([a,b])\n\n    for(var i=0;i<allcombinations.length;i++){\n        var a = allcombinations[i][0]\n        var b = allcombinations[i][1]\n        if(superimposition[a] == undefined || superimposition[a] == undefined){\n            canSuperimposed.push(false)\n            continue\n        }\n        superimposition[a].indexOf(b) != -1 ? canSuperimposed.push(true) : canSuperimposed.push(false) // Incorrect\n    }\n\n    // console.log(\"boolean array\", canSuperimposed) \n     return canSuperimposed.every(v => v === true)\n\n}\n\n\n//Description: Algorithm to superimpose\nfunction superimposeLogic(arr)\n{\n    var finalSuperImposed = []\n    var visited = arr.map(val =>\n        {\n            return 0\n        })\n    \n    for(var i=0;i<arr.length;i++)\n    {\n        if(visited[i]==0)\n        {\n            var superImpositionNotFound = true\n            var a = arr[i]\n            var addSuperImposed = []\n            var aEncoding = arr[i].map(val => {return val['encoding']})\n\n            for(var j=0;j<arr.length;j++)\n            {\n                if(visited[j]==0)\n                {\n                    if(i==j){continue} // Skip the same \n                    var b = arr[j]\n                    var bEncoding = arr[j].map(val => {return val['encoding']})\n                    if(canSuperimposed(aEncoding,bEncoding))\n                    {\n                        visited[j] = 1\n                        b.map(arr => {\n                            arr[\"superimposed\"] = true\n                        })\n                        addSuperImposed.push(...b)\n                        superImpositionNotFound = false\n                        continue\n                    }\n                }\n\n            }\n                a.map(arr => {\n                    arr[\"superimposed\"] = !superImpositionNotFound\n                })\n                addSuperImposed.push(...a)\n                \n\n                finalSuperImposed.push(addSuperImposed)\n            \n        }\n    }  \n    \n    return finalSuperImposed\n\n}\n\n\n//Description: This method returns a combined list of attributes\n//Input: Array of object containing the attribtue id and encoding recoomendation\n//Output: Array of combined and non-combined attributes. E.g [[a1_dotplot,a2_barchart],[a3_annotation]]\nfunction combineLogic(arr)\n{\n    var finalEncodingCombination = []   \n    var visited = arr.map(val =>\n        {\n            return 0\n        })\n    \n    for(var i = 0;i<arr.length;i++)\n        {\n            if(visited[i]==0)\n            {\n                var combinationNotFound = true // This variable will keep track incase the combination was found \n                var a = Object.assign({},arr[i])\n                for (var j = 0;j<arr.length;j++)\n                {\n                    if(visited[j]==0)\n                    {\n                        var b = Object.assign({},arr[j])\n                        if(a['attributeId'] == b['attributeId'])\n                        {\n                            continue\n                        }\n                        else\n                        {\n                            var combine = canCombine(a['encoding'],b['encoding'])                            \n                            if (combine)\n                            {\n                                visited[i] = 1\n                                visited[j] = 1\n                                // finalEncodingCombination.push(`${a['attributeId']}_${a['encoding']}_${b['encoding']}`)\n                                a['combined'] = true\n                                b['combined'] = true\n                                finalEncodingCombination.push([a,b])\n                                combinationNotFound = false\n                                break;\n                            }\n                        }\n                    }\n                }\n                if(combinationNotFound)\n                {\n                    a['combined'] = false\n                    finalEncodingCombination.push([a])\n                }\n            }\n        }\n\nreturn finalEncodingCombination\n    \n}\n\n\n//Description: Test function to evaluate combinations of attributes\n//Input: Array of arrays that have to be combined\n//Output: All possible combinations of the arrays\nfunction cartesian(args) {\n    var r = [], max = args.length-1;\n    function helper(arr, i) {\n        for (var j=0, l=args[i].length; j<l; j++) {\n            var a = arr.slice(0); // clone arr\n            a.push(args[i][j]);\n            if (i==max)\n                r.push(a);\n            else\n                helper(a, i+1);\n        }\n    }\n    helper([], 0);\n    return r;\n}\n\n//Description: This function will list all the tasks a user may have requested for in the dataspec at a feature level.\n//Input: An entire Feature input\n//Output: List of tasks users wants to perform\nfunction getTasks(feature){\n    let tasks = new Set()\n\n    for(var i=0;i<feature.length;i++){\n        var currentFeature = feature[i];\n\n        if(currentFeature['inputVectorObject']['inputVectorObject']['compare'] == 1)\n        {\n            tasks.add(\"compare\")\n        }\n        if(currentFeature['inputVectorObject']['inputVectorObject']['identify'] == 1)\n        {\n            tasks.add(\"identify\")\n        }\n        if(currentFeature['inputVectorObject']['inputVectorObject']['summarize'] == 1)\n        {\n            tasks.add(\"summarize\")\n        }\n        \n    }\n\n    return tasks\n}\n\n\nfunction getTracks(encodingSpecification){\n    \n    var featureKeys= Object.keys(encodingSpecification)\n    var trackList =[]\n\n    for(i=0;i<featureKeys.length;i++){\n        var tasks = getTasks(encodingSpecification[featureKeys[i]])\n        var trackPossibilities = getPossibilities(encodingSpecification[featureKeys[i]])\n        var featureId = `feature_${i}`\n        var returnTrackSpec = {[featureId]:{trackPossibilities,tasks}}\n        // console.log(`Stage 2 Output`, returnTrackSpec)\n        trackList.push(returnTrackSpec)\n    }\n    \n    return trackList\n\n}\n\nmodule.exports = getTracks"]},"metadata":{},"sourceType":"script"}