{"ast":null,"code":"const globalData = require(\"./modelDataProcessing.js\");\n\nconst stage1Model = globalData.model1;\nconst stage3Model = globalData.model3;\nconst vectorKeys = [\"featureinterconnection\", \"denseinterconnection\", \"identify\", \"compare\", \"summarize\", \"size\", \"hue\", \"saturation\", \"text\"];\n\nconst getProductProperties = require(\"./utils.js\").productProperties;\n\nconst computeSimilarity = require(\"./utils.js\").computeSimilarity;\n\nconst recommendedProducts = require(\"./utils.js\").recommendedProducts;\n\nconst productVector = getProductProperties(stage3Model, vectorKeys); //Todo: Need to figure out how to take into consideration user preferences\n//Description: Use the input from stage 2 and dataspec to create an input vector.\n//Input: \n//Output: \n\nfunction createInputVector(channels, tasks, interconnection) {\n  // Mapping attributes \n  var inputVectorObject = {};\n  var inputArray = [];\n  inputArray.push(inputVectorObject[\"featureinterconnection\"] = interconnection['featureInterconnection'] == 1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"denseinterconnection\"] = interconnection['denseInterconnection'] == 1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"identify\"] = tasks.has(\"identify\") ? 1 : 0);\n  inputArray.push(inputVectorObject[\"compare\"] = tasks.has(\"compare\") ? 1 : 0);\n  inputArray.push(inputVectorObject[\"summarize\"] = tasks.has(\"summarize\") ? 1 : 0);\n  inputArray.push(inputVectorObject[\"size\"] = channels.indexOf(\"size\") != -1 || channels.indexOf(\"position\") != -1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"hue\"] = channels.indexOf(\"hue\") != -1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"saturation\"] = channels.indexOf(\"saturation\") != -1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"text\"] = channels.indexOf(\"text\") != -1 ? 1 : 0);\n  return {\n    inputVectorObject,\n    inputArray\n  };\n} //Description: Track combinations are designed to nest though all the combinations and find trackCombinations for all possible individual trackCombinations\n//Input: Previous stage outputs\n//Output: Inputvector and Inputarray for each track and all the possible combinations.\n\n\nfunction createTrackInputVector(stage2Output, stage1Output) {\n  var trackPossibilities = stage2Output.trackPossibilities;\n  var tasks = stage2Output.tasks;\n  var interconnection = stage1Output[0]['featureConnection'];\n  var allTrackInput = []; //This loop identifies the possible combination of trackCombinations within a feature\n\n  for (var j = 0; j < trackPossibilities.length; j++) {\n    var trackCombinationInputVector = [];\n    var trackCombinations = trackPossibilities[j]; //In this loop we check for each individual track and find its input vector.\n\n    for (var k = 0; k < trackCombinations.length; k++) {\n      var channels = trackCombinations[k].map(val => {\n        return stage1Model[val['encoding']]['channel'];\n      }); // allTrackInput.push(createInputVector(channels,tasks,interconnection))\n\n      var inputVector = createInputVector(channels, tasks, interconnection);\n      trackCombinationInputVector.push({\n        inputVector,\n        trackCombinations: trackCombinations[k]\n      });\n    }\n\n    allTrackInput.push(trackCombinationInputVector);\n  } // console.log(allTrackInput)\n\n\n  return allTrackInput;\n}\n\nfunction mode(array) {\n  if (array.length == 0) return null;\n  var modeMap = {};\n  var maxEl = array[0],\n      maxCount = 1;\n\n  for (var i = 0; i < array.length; i++) {\n    var el = array[i];\n    if (modeMap[el] == null) modeMap[el] = 1;else modeMap[el]++;\n\n    if (modeMap[el] > maxCount) {\n      maxEl = el;\n      maxCount = modeMap[el];\n    }\n  }\n\n  return maxEl;\n} // Description: For each input feature, identify the types of trackCombinations\n//We need information about the \n\n\nfunction getLayout(stage2Output, stage1Output) {\n  //Layout recommendation for each possible track  indexed by feature id\n  var trackLayout = {}; // This loop divides the features, and for individual feature set identifies the types of trackCombinations.\n\n  for (var i = 0; i < stage2Output.length; i++) {\n    // We want to extract the key of the feature that we are analyzing\n    var key = Object.keys(stage2Output[i])[0]; //Track possibilities store all the tracks that our recommendatio system predicted per feature\n\n    var trackPossibilities = createTrackInputVector(stage2Output[i][`feature_${i}`], stage1Output[key]); //Initialize the features\n\n    trackLayout[key] = []; // A track consists of one or more\n\n    for (var j = 0; j < trackPossibilities.length; j++) {\n      var tracks = trackPossibilities[j];\n      var trackLayoutRecommendation = [];\n\n      for (var k = 0; k < tracks.length; k++) {\n        var inputVectorObject = tracks[k]['inputVector'];\n        var similarityScores = computeSimilarity(inputVectorObject, productVector);\n        trackLayoutRecommendation.push(recommendedProducts(similarityScores, \"tanimoto\"));\n      } //find the most common layout in the tracklayoutrecommendation array\n\n\n      var layoutRecommendation = mode(trackLayoutRecommendation);\n      trackLayout[key].push({\n        tracks,\n        layoutRecommendation: layoutRecommendation[0]\n      });\n    }\n  } // console.log(\"stage 3 outout\", trackLayout)\n\n\n  return trackLayout;\n}\n\nmodule.exports = getLayout;","map":{"version":3,"sources":["/Users/aditeyapandey/Documents/Genorec-Client/node_modules/genorec-engine/src/s3_ls.js"],"names":["globalData","require","stage1Model","model1","stage3Model","model3","vectorKeys","getProductProperties","productProperties","computeSimilarity","recommendedProducts","productVector","createInputVector","channels","tasks","interconnection","inputVectorObject","inputArray","push","has","indexOf","createTrackInputVector","stage2Output","stage1Output","trackPossibilities","allTrackInput","j","length","trackCombinationInputVector","trackCombinations","k","map","val","inputVector","mode","array","modeMap","maxEl","maxCount","i","el","getLayout","trackLayout","key","Object","keys","tracks","trackLayoutRecommendation","similarityScores","layoutRecommendation","module","exports"],"mappings":"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","sourcesContent":["const globalData = require(\"./modelDataProcessing.js\")\nconst stage1Model = globalData.model1\nconst stage3Model = globalData.model3\nconst vectorKeys = [\"featureinterconnection\",\"denseinterconnection\", \"identify\", \"compare\",\"summarize\",\"size\",\"hue\",\"saturation\",\"text\"]\nconst getProductProperties  = require(\"./utils.js\").productProperties\nconst computeSimilarity = require(\"./utils.js\").computeSimilarity\nconst recommendedProducts = require(\"./utils.js\").recommendedProducts\nconst productVector = getProductProperties(stage3Model,vectorKeys)\n\n\n//Todo: Need to figure out how to take into consideration user preferences\n\n//Description: Use the input from stage 2 and dataspec to create an input vector.\n//Input: \n//Output: \nfunction createInputVector(channels,tasks,interconnection){\n  // Mapping attributes \n  var inputVectorObject = {}\n  var inputArray = []\n\n  inputArray.push(inputVectorObject[\"featureinterconnection\"] = interconnection['featureInterconnection'] == 1 ? 1 : 0)\n  inputArray.push(inputVectorObject[\"denseinterconnection\"] = interconnection['denseInterconnection'] == 1 ? 1 : 0)\n  inputArray.push(inputVectorObject[\"identify\"] = tasks.has(\"identify\") ? 1 : 0)\n  inputArray.push(inputVectorObject[\"compare\"] = tasks.has(\"compare\") ? 1 : 0)\n  inputArray.push(inputVectorObject[\"summarize\"] = tasks.has(\"summarize\")  ? 1 : 0)\n  inputArray.push(inputVectorObject[\"size\"] = (channels.indexOf(\"size\") !=-1 || channels.indexOf(\"position\") !=-1 )  ? 1 : 0)\n  inputArray.push(inputVectorObject[\"hue\"] = channels.indexOf(\"hue\") !=-1  ? 1 : 0)\n  inputArray.push(inputVectorObject[\"saturation\"] = channels.indexOf(\"saturation\") !=-1  ? 1 : 0)\n  inputArray.push(inputVectorObject[\"text\"] = channels.indexOf(\"text\") !=-1  ? 1 : 0)\n\n  return {inputVectorObject,inputArray}\n}\n\n//Description: Track combinations are designed to nest though all the combinations and find trackCombinations for all possible individual trackCombinations\n//Input: Previous stage outputs\n//Output: Inputvector and Inputarray for each track and all the possible combinations.\nfunction createTrackInputVector(stage2Output,stage1Output){\n\n    var trackPossibilities = stage2Output.trackPossibilities\n    var tasks = stage2Output.tasks\n    \n    var interconnection = stage1Output[0]['featureConnection']\n  \n\n    var allTrackInput = []\n    //This loop identifies the possible combination of trackCombinations within a feature\n    for(var j =0; j<trackPossibilities.length; j++){\n      var trackCombinationInputVector = []\n      var trackCombinations = trackPossibilities[j]\n      //In this loop we check for each individual track and find its input vector.\n      for(var k=0; k<trackCombinations.length;k++)\n        {     \n          var channels = trackCombinations[k].map(val => {\n          return stage1Model[val['encoding']]['channel']\n        })\n        // allTrackInput.push(createInputVector(channels,tasks,interconnection))\n        var inputVector = createInputVector(channels,tasks,interconnection)\n        trackCombinationInputVector.push({inputVector,trackCombinations:trackCombinations[k]})\n      }\n      allTrackInput.push(trackCombinationInputVector)\n    }\n    // console.log(allTrackInput)\n    return allTrackInput\n}\n\nfunction mode(array)\n{\n    if(array.length == 0)\n        return null;\n    var modeMap = {};\n    var maxEl = array[0], maxCount = 1;\n    for(var i = 0; i < array.length; i++)\n    {\n        var el = array[i];\n        if(modeMap[el] == null)\n            modeMap[el] = 1;\n        else\n            modeMap[el]++;  \n        if(modeMap[el] > maxCount)\n        {\n            maxEl = el;\n            maxCount = modeMap[el];\n        }\n    }\n    return maxEl;\n}\n\n\n// Description: For each input feature, identify the types of trackCombinations\n//We need information about the \nfunction getLayout (stage2Output,stage1Output) {\n\n  //Layout recommendation for each possible track  indexed by feature id\n  var trackLayout = {}\n\n  \n  // This loop divides the features, and for individual feature set identifies the types of trackCombinations.\n  for (var i = 0; i< stage2Output.length;i++)\n  {\n    // We want to extract the key of the feature that we are analyzing\n    var key = Object.keys(stage2Output[i])[0]\n    \n    //Track possibilities store all the tracks that our recommendatio system predicted per feature\n    var trackPossibilities = createTrackInputVector(stage2Output[i][`feature_${i}`], stage1Output[key])\n    \n    //Initialize the features\n    trackLayout[key] = []\n\n    // A track consists of one or more\n    for(var j =0; j< trackPossibilities.length;j++)\n    {\n      var tracks = trackPossibilities[j]\n      var trackLayoutRecommendation = []\n      for (var k = 0; k< tracks.length; k++){\n        var inputVectorObject = tracks[k]['inputVector']\n        var similarityScores = computeSimilarity(inputVectorObject,productVector)\n        trackLayoutRecommendation.push(recommendedProducts(similarityScores,\"tanimoto\"))\n      }\n      //find the most common layout in the tracklayoutrecommendation array\n      var layoutRecommendation = mode(trackLayoutRecommendation)\n      trackLayout[key].push({tracks, layoutRecommendation:layoutRecommendation[0]})\n    }\n\n\n  } \n// console.log(\"stage 3 outout\", trackLayout)\nreturn trackLayout\n}\n\n\nmodule.exports = getLayout"]},"metadata":{},"sourceType":"script"}