{"ast":null,"code":"//https://github.com/mljs/distance#ml-distance\nvar dsMetric = require(\"ml-distance\");\n\nfunction getProductProperties(model, vectorKeys) {\n  var getProductProperties = [];\n  var productKeys = Object.keys(model);\n\n  for (var i = 0; i < productKeys.length; i++) {\n    var currentProduct = productKeys[i];\n    var tempgetProductProperties = {};\n    tempgetProductProperties[currentProduct] = [];\n    vectorKeys.map(val => {\n      tempgetProductProperties[currentProduct].push(parseInt(model[currentProduct][val]));\n    });\n    getProductProperties.push(tempgetProductProperties);\n  }\n\n  return getProductProperties;\n} // Description: Calculate the recommendation\n// Input: product and input vector\n// Output: similarity score corresponding to each output\n\n\nfunction computeSimilarity(inputVectorObject, productVector) {\n  var inpVec = inputVectorObject[\"inputArray\"];\n  var resultSimilarity = {};\n\n  for (var i = 0; i < productVector.length; i++) {\n    var obj = productVector[i];\n    var key = Object.keys(obj)[0];\n    var proVec = obj[key];\n    var similarity = dsMetric.similarity.tanimoto(inpVec, proVec);\n    var similarityEC = 1 / (1 + dsMetric.distance.euclidean(inpVec, proVec));\n    resultSimilarity[key] = {\n      'tanimoto': similarity,\n      'euclideansimilarity': similarityEC\n    };\n  }\n\n  return resultSimilarity;\n} //Input: An object with vis techniques as keys and similarity scores. Additionally, key for the similarity metric to use.\n//Output: Array of recommendation. The array allows for mutiple output in the cases where the scores are exactly similar.\n\n\nfunction recommendedProducts(similarityScores) {\n  var metric = \"tanimoto\";\n  let arr = Object.values(similarityScores);\n  let newarr = arr.map(val => {\n    return val[metric];\n  });\n  let max = Math.max(...newarr);\n  var recommendedProducts = [];\n  Object.keys(similarityScores).map(val => {\n    if (similarityScores[val][metric] == max) {\n      recommendedProducts.push(val);\n    }\n  });\n  return recommendedProducts;\n} //Description: Test function to evaluate combinations of attributes\n//Input: Array of arrays that have to be combined\n//Output: All possible combinations of the arrays\n\n\nfunction cartesian(args) {\n  var r = [],\n      max = args.length - 1;\n\n  function helper(arr, i) {\n    for (var j = 0, l = args[i].length; j < l; j++) {\n      var a = arr.slice(0); // clone arr\n\n      a.push(args[i][j]);\n      if (i == max) r.push(a);else helper(a, i + 1);\n    }\n  }\n\n  helper([], 0);\n  return r;\n}\n\nmodule.exports = {\n  productProperties: getProductProperties,\n  computeSimilarity: computeSimilarity,\n  recommendedProducts: recommendedProducts,\n  cartesian: cartesian\n};","map":{"version":3,"sources":["/Users/aditeyapandey/Documents/Genorec-Engine/src/utils.js"],"names":["dsMetric","require","getProductProperties","model","vectorKeys","productKeys","Object","keys","i","length","currentProduct","tempgetProductProperties","map","val","push","parseInt","computeSimilarity","inputVectorObject","productVector","inpVec","resultSimilarity","obj","key","proVec","similarity","tanimoto","similarityEC","distance","euclidean","recommendedProducts","similarityScores","metric","arr","values","newarr","max","Math","cartesian","args","r","helper","j","l","a","slice","module","exports","productProperties"],"mappings":"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","sourcesContent":["//https://github.com/mljs/distance#ml-distance\n\nvar dsMetric = require(\"ml-distance\")\n\nfunction getProductProperties(model,vectorKeys){\n  var getProductProperties = []\n\n  var productKeys = Object.keys(model)\n\n  for (var i=0;i<productKeys.length;i++)\n  {\n    var currentProduct = productKeys[i]\n    var tempgetProductProperties = {}\n\n    tempgetProductProperties[currentProduct]=[]\n    vectorKeys.map(val => {\n      tempgetProductProperties[currentProduct].push(parseInt(model[currentProduct][val]))\n    })\n    getProductProperties.push(tempgetProductProperties)\n  }\n  return getProductProperties\n}\n\n// Description: Calculate the recommendation\n// Input: product and input vector\n// Output: similarity score corresponding to each output\nfunction computeSimilarity(inputVectorObject,productVector){\n  var inpVec = inputVectorObject[\"inputArray\"]\n  var resultSimilarity = {}\n\n  for (var i =0;i<productVector.length;i++){\n    var obj = productVector[i];\n    var key = Object.keys(obj)[0]\n    var proVec = obj[key]\n    var similarity = dsMetric.similarity.tanimoto(inpVec,proVec)\n    var similarityEC = 1/ (1+ dsMetric.distance.euclidean(inpVec,proVec))\n    resultSimilarity[key] = {'tanimoto':similarity,'euclideansimilarity':similarityEC}\n  }\n  return resultSimilarity\n}\n\n//Input: An object with vis techniques as keys and similarity scores. Additionally, key for the similarity metric to use.\n//Output: Array of recommendation. The array allows for mutiple output in the cases where the scores are exactly similar.\nfunction recommendedProducts (similarityScores)\n{\n  var metric=\"tanimoto\"\n  let arr = Object.values(similarityScores);\n  let newarr = arr.map(val =>{\n    return val[metric]\n  })\n\n  let max = Math.max(...newarr);\n  var recommendedProducts = []\n\n  Object.keys(similarityScores).map((val) => {\n    if(similarityScores[val][metric] == max) {recommendedProducts.push(val) }\n  })\n\n  return recommendedProducts\n}\n\n//Description: Test function to evaluate combinations of attributes\n//Input: Array of arrays that have to be combined\n//Output: All possible combinations of the arrays\nfunction cartesian(args) {\n  var r = [], max = args.length-1;\n  function helper(arr, i) {\n      for (var j=0, l=args[i].length; j<l; j++) {\n          var a = arr.slice(0); // clone arr\n          a.push(args[i][j]);\n          if (i==max)\n              r.push(a);\n          else\n              helper(a, i+1);\n      }\n  }\n  helper([], 0);\n  return r;\n}\n\nmodule.exports =\n{\n  productProperties: getProductProperties,\n  computeSimilarity: computeSimilarity,\n  recommendedProducts:  recommendedProducts ,\n  cartesian: cartesian\n}"]},"metadata":{},"sourceType":"script"}