{"ast":null,"code":"// Description: This page identifies the visual encoding of each attribute avaialble in the dataset.\n// Output: Featureid -> [{attrid, inputVector, similarityScore, recommendation}]\n// inputVector consists an array and an object that store information about the input attribute.\n// similarityScore contains the score of an inputVector with all the encoding options available for genomics visualization.\n// recommendation is an array of one or more product recommendation. \nconst model = require('../model/stage1.json');\n\nconst vectorKeys = [\"quantitative\", \"categorical\", \"text\", \"sparse\", \"continous\", \"point\", \"segment\", \"identify\", \"compare\", \"summarize\"];\n\nconst globalData = require(\"./modelDataProcessing.js\");\n\nconst stage1Model = globalData.model1;\n\nconst getProductProperties = require(\"./utils.js\").productProperties;\n\nconst computeSimilarity = require(\"./utils.js\").computeSimilarity;\n\nconst recommendedProducts = require(\"./utils.js\").recommendedProducts; //Product vector only needs to be computed once\n\n\nconst productVector = getProductProperties(stage1Model, vectorKeys); // Description: This function will convert the dataspec to an array of user input\n// Description: As a side we will also store the input object vector\n// Input: The feature spec and attribute\n// Output: Vector array and object \n\nfunction createInputVector(feature, attribute) {\n  // Mapping attributes \n  var inputVectorObject = {};\n  var inputArray = []; //Vector array and object\n\n  inputArray.push(inputVectorObject[\"quantitative\"] = attribute.dataType == \"quantitative\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"categorical\"] = attribute.dataType == \"categorical\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"text\"] = attribute.dataType == \"text\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"sparse\"] = feature.featureDensity == \"sparse\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"continous\"] = feature.featureDensity == \"continous\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"point\"] = feature.featureGranularity == \"point\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"segment\"] = feature.featureGranularity == \"segment\" ? 1 : 0);\n  inputArray.push(inputVectorObject[\"identify\"] = attribute.intraAttrTask.indexOf(\"identify\") != -1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"compare\"] = attribute.intraAttrTask.indexOf(\"compare\") != -1 ? 1 : 0);\n  inputArray.push(inputVectorObject[\"summarize\"] = attribute.intraAttrTask.indexOf(\"summarize\") != -1 ? 1 : 0); //Additional elements to add to the object\n\n  inputVectorObject[\"featureInterconnection\"] = feature.featureInterconnection ? 1 : 0;\n  inputVectorObject[\"denseInterconnection\"] = feature.denseInterconnection ? 1 : 0;\n  return {\n    inputVectorObject,\n    inputArray\n  };\n} // Description: Get the type of within interconnection at a feature level\n// Input: Feature Specification\n// Output: {interconnection:boolean, denseinterconnection:boolean}\n\n\nfunction getInterconnectionFeature(feature) {\n  return {\n    featureInterconnection: feature.featureInterconnection ? 1 : 0,\n    denseInterconnection: feature.denseInterconnection ? 1 : 0\n  };\n}\n\nfunction encodeAttribute(dataspec) {\n  var partialSpecification = {};\n\n  for (var i = 0; i < dataspec.features.length; i++) {\n    var currentFeature = dataspec.features[i]; //Initiation of the partial specification\n\n    partialSpecification[`feature_${i}`] = []; //Get recommendation of the input feature vector\n\n    for (j = 0; j < currentFeature.attributes.length; j++) {\n      var currentAttribute = currentFeature.attributes[j];\n      var inputVectorObject = createInputVector(currentFeature, currentAttribute);\n      var similarityScores = computeSimilarity(inputVectorObject, productVector);\n      var recommendation = recommendedProducts(similarityScores);\n      var featureConnection = getInterconnectionFeature(currentFeature);\n      var tempAttributeStorage = {\n        'attributeId': `attribute_${j}`,\n        'inputVectorObject': inputVectorObject,\n        'similarityScore': similarityScores,\n        'recommendation': recommendation,\n        featureConnection\n      };\n      partialSpecification[`feature_${i}`].push(tempAttributeStorage);\n    }\n  }\n\n  console.log(\"Stage1 Output:\", partialSpecification);\n  return partialSpecification;\n}\n\nmodule.exports = encodeAttribute;","map":{"version":3,"sources":["/Users/aditeyapandey/Documents/Genorec_Client/node_modules/my-package/src/s1_en.js"],"names":["model","require","vectorKeys","globalData","stage1Model","model1","getProductProperties","productProperties","computeSimilarity","recommendedProducts","productVector","createInputVector","feature","attribute","inputVectorObject","inputArray","push","dataType","featureDensity","featureGranularity","intraAttrTask","indexOf","featureInterconnection","denseInterconnection","getInterconnectionFeature","encodeAttribute","dataspec","partialSpecification","i","features","length","currentFeature","j","attributes","currentAttribute","similarityScores","recommendation","featureConnection","tempAttributeStorage","console","log","module","exports"],"mappings":"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","sourcesContent":["// Description: This page identifies the visual encoding of each attribute avaialble in the dataset.\n// Output: Featureid -> [{attrid, inputVector, similarityScore, recommendation}]\n// inputVector consists an array and an object that store information about the input attribute.\n// similarityScore contains the score of an inputVector with all the encoding options available for genomics visualization.\n// recommendation is an array of one or more product recommendation. \nconst model = require('../model/stage1.json');\nconst vectorKeys = [\"quantitative\",\"categorical\",\"text\",\"sparse\",\"continous\",\"point\",\"segment\",\"identify\",\"compare\",\"summarize\"]\nconst  globalData = require(\"./modelDataProcessing.js\")\nconst stage1Model = globalData.model1\nconst getProductProperties  = require(\"./utils.js\").productProperties\nconst computeSimilarity = require(\"./utils.js\").computeSimilarity\nconst recommendedProducts = require(\"./utils.js\").recommendedProducts\n//Product vector only needs to be computed once\nconst productVector = getProductProperties(stage1Model,vectorKeys)\n\n\n\n// Description: This function will convert the dataspec to an array of user input\n// Description: As a side we will also store the input object vector\n// Input: The feature spec and attribute\n// Output: Vector array and object \nfunction createInputVector(feature,attribute){\n  \n  // Mapping attributes \n  var inputVectorObject = {}\n  var inputArray = []\n\n  //Vector array and object\n    inputArray.push(inputVectorObject[\"quantitative\"] = attribute.dataType == \"quantitative\" ? 1 : 0)\n    inputArray.push(inputVectorObject[\"categorical\"] = attribute.dataType == \"categorical\" ? 1 : 0)\n    inputArray.push(inputVectorObject[\"text\"] = attribute.dataType == \"text\" ? 1 : 0)\n    inputArray.push(inputVectorObject[\"sparse\"] = feature.featureDensity == \"sparse\" ? 1 : 0)\n    inputArray.push(inputVectorObject[\"continous\"] = feature.featureDensity == \"continous\" ? 1 : 0)\n    inputArray.push(inputVectorObject[\"point\"] = feature.featureGranularity == \"point\" ? 1:0)\n    inputArray.push(inputVectorObject[\"segment\"] = feature.featureGranularity == \"segment\" ? 1:0)\n    inputArray.push(inputVectorObject[\"identify\"] = attribute.intraAttrTask.indexOf(\"identify\") != -1 ? 1 : 0 \n    )\n    inputArray.push(inputVectorObject[\"compare\"] = attribute.intraAttrTask.indexOf(\"compare\") != -1 ? 1 : 0 )\n    inputArray.push(inputVectorObject[\"summarize\"] = attribute.intraAttrTask.indexOf(\"summarize\") != -1 ? 1 : 0 \n    )\n\n  //Additional elements to add to the object\n  inputVectorObject[\"featureInterconnection\"] = feature.featureInterconnection ? 1 : 0\n  inputVectorObject[\"denseInterconnection\"] = feature.denseInterconnection  ? 1 : 0\n  \n  return {inputVectorObject, inputArray}\n  }\n\n\n// Description: Get the type of within interconnection at a feature level\n// Input: Feature Specification\n// Output: {interconnection:boolean, denseinterconnection:boolean}\nfunction getInterconnectionFeature(feature){\n  return { featureInterconnection: feature.featureInterconnection ? 1 : 0, denseInterconnection: feature.denseInterconnection ? 1 : 0 }\n}\n\n\n\nfunction encodeAttribute(dataspec){\n\n    var partialSpecification = {}\n\n    for(var i = 0; i<dataspec.features.length;i++)\n    {\n      var currentFeature = dataspec.features[i];\n\n      //Initiation of the partial specification\n      partialSpecification[`feature_${i}`] = []\n\n      //Get recommendation of the input feature vector\n      for(j=0;j<currentFeature.attributes.length;j++){\n        var currentAttribute = currentFeature.attributes[j]\n        var inputVectorObject = createInputVector(currentFeature,currentAttribute)  \n        var similarityScores = computeSimilarity(inputVectorObject,productVector)\n        var recommendation = recommendedProducts(similarityScores)\n        var featureConnection = getInterconnectionFeature(currentFeature)\n        var tempAttributeStorage = {'attributeId':`attribute_${j}`, 'inputVectorObject':inputVectorObject, 'similarityScore': similarityScores, 'recommendation':recommendation, featureConnection}\n        \n        partialSpecification[`feature_${i}`].push(tempAttributeStorage)\n      }\n    }\n    console.log(\"Stage1 Output:\", partialSpecification)\n    return partialSpecification\n}\n\n module.exports = encodeAttribute"]},"metadata":{},"sourceType":"script"}